/*
 * Uses JSV with schema .json files that can be used to output JUnit reports.
 */
(function() {


  // Parse options declared in the URL, e.g. the test_suite filename
  var _options = {},
      url = url || YUI().config.doc.location.search;

  if (url){
    var  params = url.slice(1).split("&");
    for (var i=0; i <params.length; i++){
      var param = params[i].split("=");
      _options[param[0]] = param[1];
    }
  }

  // The actual test runner is used if only a schema and api file has been declared.
  if (_options && !_options.schema && _options.json){
    console.log('A path to a schema file is required');
  }
  if (_options && _options.schema && !_options.json){
    console.log('A path to a json file is required');
  }
  if (_options && _options.schema && _options.json){
    window.Y = YUI({
        logInclude:{"TestRunner":true},
        useConsole: true,
        useBrowserConsole: true
    }).use('test', 'console', 'io-base', function(Y){

      // use JSV
      var STRIP_COMMENTS = new RegExp(/\/\*.+?\*\/|\/\/.*(?=[\n\r])/g),
          JSV = require("./jsv").JSV,
          env = JSV.createEnvironment(),
          schema = {},
          json = {},
          report;

      // make sync requests for data, strip comments and parse as JSON
      schema = Y.io(_options.schema, {sync: true});
      schema = schema.responseText.replace(STRIP_COMMENTS, '');
      schema = JSON.parse(schema);
      json = Y.io(_options.json, {sync: true});
      json = json.responseText.replace(STRIP_COMMENTS, '');
      json = JSON.parse(json);
      report = env.validate(json, schema);

      if (report.errors.length === 0) {
        console.log('JSON is valid against the schema', report);
      } else {
        console.log('JSON is not valid against the schema: '+ report.errors.length +' errors', report);
      }

      // allow formatted reports to be generated by PhantomJS
      JSV._lastResults = report;
      JSV._options = _options;

    });
  }


})();